归档文件格式：xypsa

```imhex-pattern-language
#pragma author XY0797
#pragma description XY predictable size archive
```

# 文件后缀名解释

xy：作者名字
ps：可预测大小(predictable size)
a：归档文件(archive)

# 特性

- 支持在归档前预测文件最终大小，支持流式归档和流式还原
- 支持 AES256-CFB+HMAC-SHA256 对文件做加密和完整性保护：
- 一个归档文件只有一个密码，密码 UTF-8 编码后取 SHA256 即为 AES 和 HMAC 使用的密钥
- 可以只对文件内容加密，也可连同目录结构一起加密
- 加密文件可以检测文件是否被篡改

# 数据结构

## 定义

1. 大端字节序保存数据
2. u8 - 8 位大端字节序无符号整数
3. u16 - 16 位大端字节序无符号整数
4. u - 64 位大端字节序无符号整数

文件和目录结构的表示法：文件/文件夹视为[实体]，实体都有一个 ID[u]和父 ID[u]

xypsa 数据结构：[元数据区] [索引区] [文件数据区]

元数据记录整个文件的类型信息和特殊信息

索引区记录目录结构和实体属性

## 元数据区

1. 魔数[4 字节] - 值为`xyar`的 ACSII 码
2. 版本[u] - 值为整数 1
3. 加密类型[u8] - 0:不加密,1:只加密文件数据区内容,2:加密`索引区`和`文件数据区`的所有内容
4. 文件备注文本长度[u16]
5. 文件备注文本[UTF-8 文本]
6. 索引区大小[u]
7. 文件项总大小[u]
8. iv[16 字节] - **只有加密类型为`只加密文件数据区内容`和`加密 索引区 和 文件数据区 的所有内容`时才有这个属性**
9. 元数据区校验码[32 字节] - 如果加密类型是`不加密`，这里就是`SHA256`，否则为`MAC消息认证码`

```imhex-pattern-language
struct Metadata {
    // 魔数
    char magicNumber[4];
    // 版本
    be u64 version;
    // 加密类型
    be u8 encryptionType;
    // 文件备注文本长度
    be u16 commentTextLength;
    // 文件备注文本
    char commentText[commentTextLength];
    // 索引区大小
    be u64 indexSize;
    // 文件项总大小
    be u64 dataItemsSize;
    // 初始化向量
    if (encryptionType == 1 || encryptionType == 2) {
        u8 iv[16];
    }
    // 元数据区校验码
    char metadataCheckCode[32];
};
Metadata metadata @ 0x00;
if (metadata.encryptionType == 1 || metadata.encryptionType == 2) {
   return;
}
```

## 索引区

1. [索引项,...,索引项]
2. 索引区校验码[32 字节] - 如果加密类型是`不加密`，这里就是`SHA256`，否则为`MAC消息认证码`

### 索引项

1. 实体 ID[u] - 唯一标识一个实体，从 1 开始递增
2. 实体父 ID[u] - 指向父实体的 ID，如果是根目录，父 ID 为 0
3. 实体类型[u8] - 0:文件,1:文件夹
4. 修改时间[u] - unix 时间戳，但是单位为 100ns
5. 实体名长度[u16]
6. 实体名[UTF-8 文本]
7. 文件大小[u] - **只有文件才有这个属性**

```imhex-pattern-language
struct IndexItem {
    // 实体 ID
    be u64 id;
    // 实体父 ID
    be u64 parentId;
    // 实体类型 - 0:文件,1:文件夹
    be u8 type;
    // 修改时间
    be u64 modifyTime;
    // 实体名长度
    be u16 nameLength;
    // 实体名
    char name[nameLength];
    // 文件大小
    if (type == 0) {
        be u64 size;
    }
};
u64 indexItemStartAddress = sizeof(metadata);
u64 indexItemEndAddress = sizeof(metadata) + metadata.indexSize - 32;
IndexItem indexItems[while($ != indexItemEndAddress)] @ indexItemStartAddress;
u8 indexCheckCode[32] @ indexItemEndAddress;
```

## 文件数据区

1. [文件项,...,文件项] - 索引区中`实体类型`为文件的实体按 ID 顺序排列
2. [全局校验码] - 从 xypsa 文件的第一个字节开始，一直到文件数据区的最后一个字节，计算的校验码。如果加密类型是`不加密`，这里就是`SHA256`，否则为`MAC消息认证码`。

### 文件项

1. 实体 ID[u]
2. 文件数据[字节集]
3. `实体 ID+文件数据`校验码[32 字节] - 如果加密类型是`不加密`，这里就是`SHA256`，否则为`MAC消息认证码`

```imhex-pattern-language
import std.core;
fn getFileItemSize(u64 id) {
   u64 len = std::core::member_count(indexItems);
   for (u64 i = 0, i < len, i += 1) {
       if (indexItems[i].id == id && indexItems[i].type == 0) {
           return indexItems[i].size;
       }
   }
   return 0;
};
struct FileItem {
    // 实体 ID
    be u64 id;
    // 文件数据
    char data[getFileItemSize(id)];
    // 实体 ID+文件数据校验码
    char checkCode[32];
};
u64 fileItemStartAddress = sizeof(metadata) + metadata.indexSize;
u64 fileItemEndAddress = fileItemStartAddress + metadata.dataItemsSize;
FileItem fileItems[while($ != fileItemEndAddress)] @ fileItemStartAddress;
u8 globalCheckCode[32] @ fileItemEndAddress;
```

# 加密方法

- 如果加密类型为`不加密`，那么正常处理数据
- 如果加密类型为`只加密文件数据区内容`，那么`文件数据区`的数据在写入文件前过一遍 AES256-CFB 算法加密
- 如果加密类型为`加密 索引区 和 文件数据区 的所有内容`，那么`索引区`和`文件数据区`的数据在写入文件前过一遍 AES256-CFB 算法加密

# 解密方法

- 如果加密类型为`不加密`，那么正常处理数据
- 如果加密类型为`只加密文件数据区内容`，那么读取`文件数据区`前向用户询问密码，读取`文件数据区`时过一遍 AES256-CFB 算法解密再解析
- 如果加密类型为`加密 索引区 和 文件数据区 的所有内容`，那么打开归档文件时向用户询问密码，读取`索引区`和`文件数据区`时过一遍 AES256-CFB 算法解密再解析

# 归档方法

## 1. 准备阶段

1. **初始化归档器**：

   - 创建归档器实例，指定加密类型（0:不加密 / 1:仅加密文件内容 / 2:加密索引和文件内容）
   - 若指定加密类型非 0，需传入密码字符串

2. **添加待归档对象**：

   - 通过 `add_file()` 添加单个文件，路径需为绝对路径或相对于当前工作目录的有效路径
   - 通过 `add_dir()` 添加目录，将在`预运算阶段`递归处理目录下所有子目录和文件
   - 重复添加同一路径将自动去重

3. **设置元信息**：
   - 通过 `set_comment()` 设置归档文件备注，文本将按 UTF-8 编码存储
   - 通过 `set_block_size()` 设置流式输出块大小（默认 128KB），影响迭代时每次取出的字节数。

## 2. 预计算阶段

1. **初始化归档结构**：

   - 调用 `init()` 方法后添加文件/目录将无效，所有相关的文件都禁止其他进程写入(仅限 windows，且没有禁用预打开)
   - 深度优先遍历所有目录，生成索引项树形结构：
     - 准备两个空的数组，分别叫`索引项数组`和`文件项数组`，用于存储`索引项`和`文件项`
     - `索引项数组`存储`索引项`，和上文`数据结构 - 索引区`定义的`索引项`结构相同。
     - `文件项数组`存储`文件项`，和上文`数据结构 - 文件数据区`定义的`文件项`结构不同，这里仅存储`实体ID`、`文件路径`、`文件长度`组成的三元组。
     - 根目录实体的父 ID=0，实体 ID 从 1 开始顺序分配

2. **加密初始化**：

   - 若启用加密：
     - 生成 16 字节密码学安全 IV
     - 将密码转换为 UTF-8 字节流，进行 SHA256 计算，得到的结果作为加密密钥
     - 初始化 AES256-CFB 加密器：
   - 初始化全局校验码上下文：
     - 若启用加密：使用 HMAC-SHA256 作为全局校验码上下文
     - 若未启用加密：使用 SHA256 作为全局校验码上下文

3. **精确预测大小**：

   - 参考下一小节的方法

## 预测文件大小的方法

需要得到的信息：

1. `文件备注文本长度`：utf-8 编码后的字节长度
2. `iv长度`：如果加密类型为不加密则取 0，否则取 16
3. `实体个数`
4. `文件实体个数`
5. `实体名长度总和`：utf-8 编码后的字节长度
6. `文件实体的文件大小总和`

各个分段的大小：

- 元数据区：$4+8+2+\bold{文件备注文本长度}+8+8+1+\bold{iv长度}+32$
- 索引区：$(8+8+1+8+2) \times \bold{实体个数}+\bold{实体名长度总和}+8 \times \bold{文件实体个数}+32$
- 文件数据区：$(8+32) \times \bold{文件实体个数}+\bold{文件实体的文件大小总和}+32$

要得到文件的总大小只需要把各个分段大小加起来即可：

```python
文件的总大小=文件备注文本长度+iv长度+实体名长度总和+文件实体的文件大小总和+27*实体个数+48*文件实体个数+127
```

## 3. 流式生成阶段

自定义`__next__`方法流式生成数据

将每个区的数据生成封装成一个生成器，在`__next__`方法内部控制生成器的状态，通过`next(生成器)`取出数据

在`__next__`方法内部设置数据缓冲区，确保每次取出 `block_size` 字节，只有在最后一次才可能取出不足 `block_size` 的数据。

1. **元数据区生成**：

   - 头部写入魔数 `xyar`（ASCII）
   - 版本号按大端 8 字节写入（固定为 1）
   - 备注文本按 [2 字节长度头 + UTF-8 数据] 格式写入
   - 记录索引区/文件项总大小的预计算大小
   - 若启用加密，追加 16 字节 IV
   - 计算元数据区校验码并追加
   - yield 元数据区数据

2. **索引区生成**：

   - 按实体 ID 顺序写入索引项：
     - 文件实体：`[ID(u64)][父ID(u64)][类型0(u8)][修改时间(u64)][名称长度(u64)][名称(UTF-8)][文件大小(u64)]`
     - 目录实体：`[ID(u64)][父ID(u64)][类型0(u8)][修改时间(u64)][名称长度(u64)][名称(UTF-8)]`
   - 分块策略：
     - 连续生成索引项，生成完某个索引项后发现数据积累到 `block_size` 时触发加密（若需）并 yield
     - 最后追加索引区校验码（32 字节），加密（若需）并 yield

3. **文件数据区生成**：

   - 准备数据缓冲区
   - 按实体 ID 顺序处理每个文件：
     1. 创建文件项校验码上下文，若启用加密，使用 HMAC-SHA256 计算，否则使用 SHA256 计算
     2. 追加 8 字节实体 ID 到缓冲区，更新文件项校验码上下文
     3. 分块读取原始文件数据：
        - 每次读取能使缓冲区达到 `block_size` 的字节数
        - 实时更新文件项校验码上下文
        - 累积数据到缓冲区，积累到 `block_size` 时触发加密（若需）并 yield
     4. 文件读取完成后关闭文件，结束文件项校验码上下文
     5. 统计实际上该文件对象读出的字节数，与文件大小进行比对，如果不匹配，立即抛出 `ValueError`
     6. 追加 32 字节文件项校验码到缓冲区
     7. 所有文件项处理完成后，如果缓冲区内还有数据，触发加密（若需）并 yield
     8. 追加全局校验码：
        - 计算从文件起始到文件数据区末尾的全局校验码，计算的是加密前的数据
        - 若启用加密，使用 HMAC-SHA256 计算，否则使用 SHA256 计算
        - 如果启用了加密，yield 加密后的全局校验码，否则直接 yield 全局校验码。

## 4. 异常处理

1. **文件访问冲突**：

   - 打开文件失败，立即抛出 `ValueError`
   - 生成流时发现读取文件的长度不等于索引中记录的长度，立即抛出 `ValueError`

2. **加密参数不匹配**：

   - 若加密类型非 0 但未提供密码，初始化时修改模式为不加密
   - 若加密类型为 0 但提供了密码，初始化时设置密码为 None

# 流式还原方法

还原的目标是从 `.xypsa` 归档文件中提取文件和目录结构，并确保数据的完整性和安全性。

因为流式还原的特性，如果文件是加密的，用户需要提前给出密码。

## 1. 初始化还原过程

1. 打开归档文件：以二进制模式打开 `.xypsa` 文件，准备读取数据。
2. 读取元数据区：
   - 如果用户提供了密码，则构造 HMAC-SHA256 的哈希上下文，用于计算元数据区的 MAC。如果用户没有提供密码，则构造 SHA256 哈希上下文，用于计算元数据区的 SHA256 值。
   - 读取前 4 字节，验证魔数是否为 `xyar` 的 ASCII 码。如果不是，则文件格式错误，终止还原过程。
   - 读取版本号（`u`），确保版本号为 1。如果不是，则文件版本不支持，终止还原过程。
   - 读取加密类型（`u8`），确定文件是否加密。如果加密了却没有提供密码，则终止还原过程。如果没加密却提供了密码，则终止还原过程。
   - 读取文件备注文本长度（`u16`），然后读取相应长度的 UTF-8 文本作为文件备注。
   - 读取索引区大小（`u`）和文件项总大小（`u`）。
   - 读取 IV（16 字节）。如果加密类型为 `不加密`，则没有此项，不需要读取这 16 字节。如果有此项，读取 IV 后，构造 AES256-CFB 解密器。
   - 将哈希上下文复制一份，复制出来的那份作为`全局校验码的哈希上下文`。原本的哈希上下文则停止计算，取出 MAC/哈希，然后读取元数据区校验码（32 字节），并且`全局校验码的哈希上下文`继续计算这 32 字节数据。
   - 验证元数据区完整性：把目前计算得到的 MAC/哈希与读取的校验码进行比对。如果不匹配，则文件损坏，终止还原过程。

## 2. 解析索引区

1. 读取索引区：
   - 如果用户提供了密码，则构造 HMAC-SHA256 的哈希上下文，用于计算索引区的 MAC。如果用户没有提供密码，则构造 SHA256 哈希上下文，用于计算索引区的 SHA256 值。
   - 用户流式提供索引区的数据。
   - 如果加密类型为 `加密 索引区 和 文件数据区 的所有内容`，则每次读入数据后，使用 AES256-CFB 算法解密索引区数据，然后再压入`全局校验码的哈希上下文`。否则读入数据就直接压入`全局校验码的哈希上下文`。
   - 压入`全局校验码的哈希上下文`的同时，数据也压入到`索引区校验码的哈希上下文`。
2. 解析索引区：
   - 逐个解析索引项，解析实体 ID、父实体 ID、实体类型、修改时间、实体名长度、实体名以及文件大小（如果是文件）。
   - 根据解析的索引项，构建目录树结构，并创建出相应的目录。
   - 如果读取的数据达到了`索引区大小-32`，但是仍然处于解析索引项的状态，说明文件损坏，终止还原过程。如果读取的数据达到了`索引区大小-32`，并且刚好解析完一个索引项，则进入下一阶段。
3. 验证索引区完整性：
   - 读取索引区校验码（32 字节）。
   - 索引区校验码的哈希上下文停止计算，取出 MAC/哈希，与读取的校验码进行比对。如果不匹配，则文件损坏，终止还原过程。

回退操作：此阶段已经创建了目录，如果终止了还原过程，需要删除已经创建的目录；只需要删除挂在根下的目录即可。

## 3. 解析文件数据区

1. 读取文件数据区：
   - 用户流式提供文件数据区的数据。
   - 如果加密类型为 `加密 索引区 和 文件数据区 的所有内容`，则每次读入数据后，使用 AES256-CFB 算法解密文件数据区数据，然后再压入`全局校验码的哈希上下文`。否则读入数据就直接压入`全局校验码的哈希上下文`。
2. 逐个解析文件项：
   - 如果用户提供了密码，则构造 HMAC-SHA256 的哈希上下文，用于计算文件项的 MAC。如果用户没有提供密码，则构造 SHA256 哈希上下文，用于计算文件项的 SHA256 值。
   - 读入实体 ID，根据实体 ID 找到相应的实体，并以二进制写入方式打开对应的文件，如果文件存在则清空文件内容，共享方式为禁止其它进程写。
   - 把`实体ID`压入`文件项的哈希上下文`。
   - 读取文件数据，写入到文件中。数据写到文件前，把数据压入`文件项的哈希上下文`。
   - 写入文件的数据到达对应文件大小后，关闭文件。
   - 停止计算`文件项的哈希上下文`，取出 MAC/哈希。读取文件项校验码（32 字节），与 MAC/哈希进行比对。如果不匹配，则文件损坏，终止还原过程。
   - 如果读取的数据达到了`文件项总大小`，但是仍然处于解析文件项的状态，说明文件损坏，终止还原过程。如果读取的数据达到了`文件项总大小`，并且刚好解析完一个文件项，则进入下一阶段。
3. 验证全局完整性
   - 全局校验码的哈希上下文停止计算，取出 MAC/哈希
   - 读取文件的最后 32 字节作为全局校验码
   - 计算得出的校验码与读取的校验码进行比对。如果不匹配，则文件损坏，终止还原过程。

回退操作：此阶段已经还原了所有目录和文件，如果终止了还原过程，需要删除已经还原的目录文件；只需要删除挂在根下的目录和文件即可。

## 5. 完成还原

1. 关闭文件：关闭 `.xypsa` 文件。
2. 输出结果：输出还原的文件和目录结构，并提示用户还原过程已完成。

# 归档解档器的技术选型

- 编程语言：Python
- 密码学库：cryptography

使用 Python 语言开发，可以方便的跨平台。

密码学库使用 cryptography 库，该库支持 AES256-CFB+HMAC-SHA256 的加密算法，也支持计算 SHA256，并且可以流式处理数据。该库底层绑定 Rust 语言编写的二进制文件，其内容为 OpenSSL 库，可以高效利用硬件。

# 归档代码实现

## API 设计

`XYpsaGenStream`类

- `__init__(self,encrypt_type: int, password: str = None)`：构造函数，参数为加密类型和密码。加密类型：0:不加密,1:只加密文件数据区内容,2:加密文件名和文件。如果提供的 password 为 None，则无论加密类型如何，都不加密。
- `add_file(self, file_path: str)`：添加文件，参数为文件路径。
- `add_dir(self, dir_path: str)`：添加目录，参数为目录路径。
- `set_comment(self, comment: str)`：设置文件备注。
- `set_block_size(self, block_size: int)`：设置迭代器返回的数据块大小，已经开始流式生成了也可修改，修改实时生效。迭代器最后一次返回的数据长度可能会小于数据块大小。
- `init(self, iv: bytes = None) -> list[str]`：初始化，打开文件并且生成元数据和目录结构，精确预测文件总大小。可自己指定 iv，如果为 None 或长度不是 16 字节，则随机生成。返回无权限访问的文件/文件夹列表。
- `copy_init(self, other: "XYpsaGenStream")`：拷贝初始化，从另一个已经初始化的`XYpsaGenStream`对象拷贝除了流式生成上下文外的所有数据，拷贝后从 0 开始流式生成。
- `skip(self, target_offset: int)`：跳过一定的字节数，直到目标偏移量为止。
- `__iter__(self)`：返回 self。
- `__next__(self)`：流式生成归档文件，返回字节集的大小等于 block_size，最后一次返回的数据大小可能会小于 block_size。如果未初始化，则抛出异常。如果已经生成完所有数据，则抛出 StopIteration 异常。
- `__len__(self)`：返回文件总大小，如果未初始化，则抛出异常。
- `offset`：当前已生成且被取出的字节数。
- `pre_open_files`：是否预先打开文件对象，默认为 True。如果为 False，则在流式生成时才打开文件。

## 代码实现

参考`XYpsaGenStream.py`

# 解档代码实现

## API 设计

`XYpsaParseStream`类

- `__init__(self)`：构造函数。
- `set_password(self, password: str)`：设置解档使用的密码。
- `set_block_size(self, block_size: int)`：设置迭代文件数据时返回的数据块大小，已经开始流式解析了也可修改，修改实时生效。最后一个数据块的长度可能会小于数据块大小。
- `start_parse(self, data: Generator[bytes | bytearray, None, None])`：开始解档，方法立即返回三个生成器：元数据信息生成器、索引信息生成器、文件项生成器。调用方需要按顺序调用这三个生成器取出流式解档结果。如果迭代生成器的顺序不对，抛出`XYpsaInvalidIterationSequenceError`异常。如果遇到文件损坏，生成器内抛出`XYpsaCheckError`异常。
  - 元数据信息生成器：每次迭代得到文件元数据信息的键值对
    Generator[Tuple[str, int | str | bytes | None], None, None]
    1. 版本 - "version"[int]
    2. 加密类型 - "encrypt_type"[int]
    3. 文件备注 - "comment"[str]
    4. 索引区大小 - "index_size"[int]
    5. 文件项总大小 - "file_items_size"[int]
    6. iv - "iv"[None | bytes]
    7. 元数据区校验码 - "meta_data_check_code"[bytes]
  - 索引信息生成器：每次迭代得到一个索引项的字典
    Generator[Dict[str, int | str], None, None]
    ```
    {
      "id": [int],
      "parent_id": [int],
      "type": [int],
      "mtime": [int],
      "name": [str],
      "size": [int] /* 如果是目录则没有size */
    }
    ```
  - 文件项生成器：每次迭代得到一个由`实体id`和`文件数据生成器`组成的元组。得到文件数据生成器后，必须迭代完成文件数据生成器才能迭代下一个文件项，否则抛出`XYpsaInvalidIterationSequenceError`异常。
    Tuple[int, Generator[bytes, None, None]]
    - 文件数据生成器：每次迭代得到一个数据块，按顺序拼接所有的数据块就能得到完整的文件。
      数据块的大小等于 block_size，最后一个数据块的长度可能会小于 block_size。
      迭代最后一个数据块后，再次迭代会进行完整性校验，如果正常则抛出`StopIteration`异常，如果文件损坏则抛出`XYpsaCheckError`异常。
    - 迭代完最后一个文件项后，再次迭代会进行全文件完整性校验。如果正常则抛出`StopIteration`异常，如果文件损坏则抛出`XYpsaCheckError`异常。

## 代码实现

参考`XYpsaParseStream.py`
